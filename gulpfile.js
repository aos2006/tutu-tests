"use strict";const gulp = require('gulp');const l = require('gulp-load-plugins')();const sprite = require('gulp.spritesmith');const path = require('path');const rigger = require('gulp-rigger');const cheerio = require('gulp-cheerio');const imagemin = require('gulp-imagemin');const fontgen = require('gulp-fontgen');const gutil = require('gulp-util');const webpack = require('webpack');const webpackConfig = require('./webpack.config.babel');const WebpackDevServer = require('webpack-dev-server');const babel = require('gulp-babel');const bs = require('browser-sync').create();const fs = require('fs');const del = require('del');const ejs = require('ejs');const basePath = './src/';const buildPath = './build/';const paths = {  js: {    src: basePath + 'js/*.js',    dist: buildPath + 'js/'  },  sass: {    src: basePath + 'sass/screen.sass',    dist: buildPath + 'css/'  },  twig: {    pages: basePath + 'pages/*.twig',    src: basePath + 'blocks/**/*.twig',    dist: buildPath  },  fonts: {    src: basePath + 'fonts/*.*',    dist: buildPath + 'fonts/'  },  img: {    src: basePath + 'img/**/*.{jpg,png}',    dist: buildPath + 'img/',    jpg: {      src: basePath + 'blocks/**/*.jpg',      dist: buildPath + 'img/'    },    png: {      src: basePath + 'blocks/**/*.png',      dist: basePath + 'sprites/png/'    },    svg: {      src: basePath + 'blocks/**/*.svg',      dist: basePath + 'sprites/svg/',      twigTemplatePath: basePath + 'sprites/svg/svg-template.twig',      scssTemplatePath: basePath + 'sass/helpers/_svg-sprite-template.scss'    }  }}function lazyIntegration(task, path, options){  "use strict";  options.task = task;  gulp.task(task, function(callback){    var taskType = require(path).call(this, options);    return taskType(callback);  });}lazyIntegration('styles', './gulpTasks/styles.js', {  src: paths.sass.src,  dist: paths.sass.dist});lazyIntegration('fonts', './gulpTasks/fonts.js', {  src: paths.fonts.src,  dist: paths.fonts.dist});lazyIntegration('img:resize', './gulpTasks/image-resize.js', {  src: paths.img.jpg.src,  dist: paths.img.jpg.dist});lazyIntegration('img:min', './gulpTasks/image-min.js', {  src: paths.img.src,  dist: paths.img.dist});lazyIntegration('svg:sprites', './gulpTasks/svg-sprites.js', {  src: paths.img.svg.src,  dist: paths.img.svg.dist,  scssTemplatePath: paths.img.svg.scssTemplatePath,  twigTemplatePath: paths.img.svg.twigTemplatePath,  dirname: __dirname});lazyIntegration('copy:img', './gulpTasks/copy.js', {  src: paths.img.src,  dist: paths.img.dist,});lazyIntegration('copy:fonts', './gulpTasks/copy.js', {  src: paths.fonts.src,  dist: paths.fonts.dist,});lazyIntegration('server', './gulpTasks/server.js', {});lazyIntegration('rev', './gulpTasks/rev.js', {});lazyIntegration('svg:min', './gulpTasks/svgmin.js', {  src: paths.img.svg.src,  dist: paths.img.svg.dist});lazyIntegration('svg:attr', './gulpTasks/svg-remove-attributes.js', {  src: paths.img.svg.src,  dist: paths.img.svg.dist});lazyIntegration('svg:replace', './gulpTasks/svg-bug-fixes.js', {  src: paths.img.svg.src,  dist: paths.img.svg.dist});lazyIntegration('html:svg', './gulpTasks/html-build.js', {  src: paths.twig.src,  dist: paths.twig.dist});lazyIntegration('js:build', './gulpTasks/js-build.js', {  src: paths.js.src,  dist: paths.js.dist});gulp.task('compile', function () {  'use strict';  var twig = require('gulp-twig');  return gulp.src(paths.twig.pages)    .pipe(twig())    .pipe(gulp.dest(paths.twig.dist));});gulp.task('sprite:png', function (callback) {  var spriteData = gulp.src(paths.img.png.src)    .pipe(sprite({      // retinaSrcFilter: ['src/img/icons-png2x/*@2x.png'],      // retinaImgName: 'png-sprite2x.png',      // imgName: 'png-sprite.png',      // cssName: '_png-sprite.scss',      // cssFormat: 'scss',      imgPath: '../img/sprite.png',      algorithm: 'top-down',      retinaSrcFilter: ['src/blocks/**/*@2x.png'],      imgName: 'sprite.png',      retinaImgName: '../img/sprite@2x.png',      cssName: 'png-sprite.sass'    }));  spriteData.img.pipe(gulp.dest(basePath + 'sprites/png/'));  l.debug({title: 'sprite-images:create'});  spriteData.css.pipe(gulp.dest(basePath + 'sass/helpers/'));  l.debug({title: 'sprite-sass:create'});  callback();});//gulp.task('default', gulp.series('webpack'));gulp.task('babel', function () {  return gulp.src('./src/js/main.js')      .pipe(babel())      .pipe(gulp.dest('target'));});const tasks = new Map();function run(task) {  const start = new Date();  console.log(`Starting '${task}'...`);  return Promise.resolve().then(() => tasks.get(task)()).then(() => {    console.log(`Finished '${task}' after ${new Date().getTime() - start.getTime()}ms`);  }, err => console.error(err.stack));}gulp.task('babel:server', () => {  let count = 0;  global.HMR = !process.argv.includes('--no-hmr'); // Hot Module Replacement (HMR)  return new Promise(resolve => {    const webpackConfig = require('./webpack.config.babel');    const compiler = webpack(webpackConfig);    // Node.js middleware that compiles application in watch mode with HMR support    // http://webpack.github.io/docs/webpack-dev-middleware.html    const webpackDevMiddleware = require('webpack-dev-middleware')(compiler, {      publicPath: webpackConfig.output.publicPath,      stats: webpackConfig.stats,    });    compiler.plugin('done', stats => {      // Generate index.html page      const bundle = stats.compilation.chunks.find(x => x.name === 'main').files[0];      //const output = render({ debug: true, bundle: `/build/js/${bundle}`});      // Launch Browsersync after the initial bundling is complete      // For more information visit https://browsersync.io/docs/options      if (++count === 1) {        bs.init({          host: "192.168.1.64",          port: process.env.PORT || 3000,          ui: { port: Number(process.env.PORT || 3000) + 1 },          server: {            baseDir: "./build",            startPath: "/",            index: "index.html",            middleware: [              webpackDevMiddleware,              require('webpack-hot-middleware')(compiler),              require('connect-history-api-fallback')(),            ],          },        }, resolve);      }    });  });});gulp.task('build', gulp.series('copy:img','copy:fonts','fonts', 'sprite:png','svg:min', 'svg:sprites', 'styles', 'compile', 'img:resize', 'img:min'));gulp.task('watch', function(){  gulp.watch(basePath + 'sass/**/*.sass', gulp.series('styles'));  gulp.watch(basePath + '**/*.twig', gulp.series('compile'));  //gulp.watch(basePath + 'js/*.js', gulp.series('js:build'));  gulp.watch([      basePath + 'img/**/*.*',      basePath + 'fonts/**/*.*'  ], gulp.series(['copy:img', 'copy:fonts']));  gulp.watch(basePath + 'blocks/**/*.png', gulp.series('sprite:png'));  gulp.watch(basePath + 'blocks/**/*.svg', gulp.series('svg:sprites'));});gulp.task('dev', gulp.series('build', gulp.parallel('watch', 'babel:server')));